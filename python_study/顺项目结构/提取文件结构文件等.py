import 切换当前目录
import os   
import re

要提取的文件夹路径 = r'''
C:\Users\11923\Documents\GitHub\Learning-database\shortlink
'''.strip()

# 添加忽略文件夹列表 #todo：选择模式的 忽略 和 选择和忽略 没做好  忽略只弄了正则匹配文件名的
忽略or选择='忽略'  # 选择模式：无、忽略、选择、选择和忽略

# 支持正则表达式 {需要忽略的文件夹名字，需要忽略的文件名}
# '.idea','.git', 'node_modules','.gitignore','LICENSE','format'
需要忽略的文件夹名字 = {}
# '__pycache__'
需要忽略的文件夹相对顶层目录 = {}
# r'.*\.pyc$', r'.*\.pyo$', r'.*\.pyd$'
需要忽略的文件名 = {} # 具体指定要忽略的文件类型
# r'.*/__pycache__/.*'
需要忽略的文件相对顶层目录 = {}

# 不支持正则表达式
# 这里用的是相对顶层目录的相对路径
就只选择文件夹相对顶层目录={'admin'} # ./xxx






def 提取目标文件夹结构(目标文件夹路径, 当前相对路径='.'):
    """
    递归提取目标文件夹的结构
    返回一个字典，包含文件夹的层级结构
    参数:
        目标文件夹路径: 完整的文件夹路径
        当前相对路径: 相对于起始目录的路径，用于匹配选择列表
    """
    结构 = {
        '名称': os.path.basename(目标文件夹路径),
        '类型': '文件夹',
        '子项': []

    }
    # 查看当前相对路径 从.不断遍历其子目录等  xxx\xxx\xx
    # print(当前相对路径) 

    # 处理选择和忽略逻辑
    if 忽略or选择 == '选择和忽略':
        pass #todo：选择和忽略 没做好
    elif 忽略or选择 == '忽略':
        pass #todo：忽略 没做好
    elif 忽略or选择 == '选择':
        # 选择模式：只处理指定的目录
        if 当前相对路径 != '.':  # 不是根目录
            当前相对路径 = os.path.normpath(当前相对路径)
            # 取当前路劲 /xxx/xx 转为xxx/xx 然后匹配
            if not any(当前相对路径.startswith(选择路径.lstrip('/')) for 选择路径 in 就只选择文件夹相对顶层目录):
                return None
    
    try:
        # 获取目录下所有内容
        目录内容 = os.listdir(目标文件夹路径)
        
        # 先处理文件夹，再处理文件（保持排序）
        文件夹列表 = []
        文件列表 = []
        
        for 项目 in 目录内容:
            完整路径 = os.path.join(目标文件夹路径, 项目)
            新相对路径 = os.path.join(当前相对路径, 项目)
            新相对路径 = os.path.normpath(新相对路径)
            
            if os.path.isdir(完整路径):
                文件夹列表.append((项目, 新相对路径))
            elif os.path.isfile(完整路径):
                if 忽略or选择 == '忽略':
                    if any(re.match(忽略文件名, 项目) for 忽略文件名 in 需要忽略的文件名):
                        continue
                文件列表.append(项目)
        
        # 处理所有文件夹
        for 文件夹, 新相对路径 in sorted(文件夹列表):
            完整路径 = os.path.join(目标文件夹路径, 文件夹)
            子结构 = 提取目标文件夹结构(完整路径, 新相对路径)
            if 子结构:
                结构['子项'].append(子结构)
        
        # 处理所有文件
        for 文件 in sorted(文件列表):
            完整路径 = os.path.join(目标文件夹路径, 文件)
            文件结构 = {
                '名称': 文件,
                '类型': '文件',
                '路径': 完整路径
            }
            结构['子项'].append(文件结构)
            
        return 结构
    except Exception as e:
        print(f"处理文件夹 {目标文件夹路径} 时出错：{str(e)}")
        return 结构

def 打印文件夹结构(结构, 层级=0, 最大层级=2):
    """
    打印文件夹结构的辅助函数
    参数:
        结构: 文件夹结构字典
        层级: 当前层级
        最大层级: 最大打印层级，None表示打印所有层级
    """
    缩进 = '    ' * 层级
    print(f"{缩进}{结构['名称']}")
    
    # 如果达到最大层级或不是文件夹，就返回
    if 最大层级 is not None and 层级 >= 最大层级:
        if 结构['类型'] == '文件夹' and 结构['子项']:
            print(f"{缩进}    ...")  # 表示还有更多内容
        return
    
    if 结构['类型'] == '文件夹':
        for 子项 in 结构['子项']:
            打印文件夹结构(子项, 层级 + 1, 最大层级)


def 转正规化路径(路径):
    return os.path.normpath(路径)

def 生成模块介绍(目标文件夹结构):
    if not 目标文件夹结构:  # 添加空值检查
        print("警告：没有找到有效的文件夹结构")
        return "## 未找到符合条件的文件夹结构"
        
    介绍文本 = []
    
    def 递归生成介绍(当前结构, 层级=0):
        if not 当前结构:  # 添加空值检查
            return
            
        缩进 = '  ' * 层级
        名称 = 当前结构['名称']
        
        if 当前结构['类型'] == '文件夹':
            # 第一层显示完整路径和##
            if 层级 == 0:
                介绍文本.append(f"## {名称}/")
            else:
                # 其他层级使用 - 符号
                介绍文本.append(f"{缩进}- {名称}/  TODO：gptapi提供说明")
            
            # 递归处理子项
            for 子项 in 当前结构['子项']:
                递归生成介绍(子项, 层级 + 1)
        else:
            # 文件显示方式，同样使用 - 符号
            介绍文本.append(f"{缩进}- {名称}  TODO：gptapi提供说明")

    递归生成介绍(目标文件夹结构)
    return '\n'.join(介绍文本)



def 测试():
    正规化路径 = 转正规化路径(要提取的文件夹路径)
    print('正规化路径：', 正规化路径)
    
    目标文件夹结构 = 提取目标文件夹结构(正规化路径)
    if not 目标文件夹结构:  # 添加空值检查
        print("错误：无法获取文件夹结构，请检查路径和过滤条件")
        return
    
    # 打印文件夹结构(目标文件夹结构, 0, 1)
    # 打印结构的总体字数
    print(f"结构的总字数：{len(str(目标文件夹结构))}")
    模块介绍 = 生成模块介绍(目标文件夹结构)
    # print('\n模块介绍：')
    # print(模块介绍)
    
    # 保存到文件
    with open('模块介绍.md', 'w', encoding='utf-8') as f:
        f.write(模块介绍)

if __name__ == '__main__':
    测试()
