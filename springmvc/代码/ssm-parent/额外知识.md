
# 日志系统
## SLF4j



# springboot基础功能
## SpringApplication
```markdown
### 自定义 banner
在springboot-01-demo\src\main\resources\application.properties和springboot-01-demo\src\main\resources\banner.txt中演示
启动项目出现的一大坨字符
- 配置文件中设置：spring.banner.location=classpath:banner.txt
- 类路径添加 banner.txt 在里边整上想弄的
- 可以使用在线 ASCII 艺术生成器：https://www.bootschool.net/ascii
### 自定义 SpringApplication
在springboot-01-demo\src\main\java\com\atguigu\boot\Springboot01DemoApplication.java中演示
有两种方式可以自定义 SpringApplication：
1. 使用 new SpringApplication()
   - 直接创建 SpringApplication 实例，然后自定义其属性
2. 使用 new SpringApplicationBuilder()
   - 使用 Builder 模式来创建和配置 SpringApplication
这两种方法都允许你自定义 SpringApplication 的各种属性和行为，例如：
- 禁用特定的自动配置类
- 设置应用程序类型
- 自定义 banner 模式
- 添加自定义的监听器
- 等等
示例代码：

```java
// 方法 1: 使用 new SpringApplication()
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MyApp.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}
// 方法 2: 使用 new SpringApplicationBuilder()
public static void main(String[] args) {
    new SpringApplicationBuilder()
        .sources(MyApp.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);
}
```
通过这些方法，你可以更精细地控制 Spring Boot 应用程序的启动过程和行为。
```

## yaml配置文件
如果yaml和properties同时出现相同配置，则properties的优先级更高

在springboot-01-demo\src\main\resources\application.yaml中演示属性(list，map，对象)的具体赋值语法等
```markdown
# SpringBoot 配置管理
## 痛点
SpringBoot 集中化管理配置，通常使用 application.properties
## 问题
- 配置多以后难以阅读和修改
- 层级结构辨识度不高
## YAML 配置文件
为解决上述问题，可以使用 YAML 格式的配置文件。
### YAML 语法规则
1. 大小写敏感
2. 键值对写法
   - 使用格式：`key: value`
   - 注意：冒号后面要有一个空格
3. 使用缩进表示层级关系
   - 缩进时不允许使用 Tab 键，只能使用空格
   - 缩进的空格数目不重要，只要相同层级的元素左对齐即可
4. 注释
   - 以 `#` 开头的行为注释，从这个字符一直到行尾，都会被解析器忽略
5. Value 支持的数据类型
   - 对象：键值对的集合
     例如：映射（map）/ 哈希（hash）/ 字典（dictionary）
   - 数组：一组按次序排列的值
     例如：序列（sequence）/ 列表（list）
   - 纯量：单个的、不可再分的值
     例如：字符串、数字、布尔值、日期
使用 YAML 格式可以提高配置文件的可读性和结构化程度，特别是在处理复杂配置时更有优势。
```

## 属性绑定
@ConfigurationProperties

# @SpringBootApplication注解
```markdown
3个子注解：
@SpringBootConfiguration：容器中的普通组件
    @Configuration：指定这是一个配置类
@EnableAutoConfiguration：开启自动配置
    @AutoConfigurationPackage：指定包扫描规则，扫描主程序所在包及其子包 （哪些要） （批量导入组件）
    @Import(AutoConfigurationImportSelector.class)：在类路径下找到文件：
META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports（在spring-boot-autoconfigure包下），导入152个自动配置类。 org.springframework.boot.autoconfigure.AutoConfiguration是@AutoConfigurationPackage的子类全类名
@ComponentScan：包扫描，扫描主程序所在包及其子包，排除哪些不要 （哪些不要）
```
解释为什么配了数据源后，springboot会自动配置好数据源：
配了数据源后，根据条件注解就不会再配了
<img alt="图 21" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727787057423.png" />  

解释为什么自动导入了HikariDataSource：
因为springboot默认加载了HikariDataSource依赖，所以这里会检测到，然后导入hikariDataSource，用户已经配置了就不放，用户没配置就默认
<img alt="图 23" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727787275329.png" />  

解释属性自动配置（开启属性与配置文件的自动绑定功能）
<img alt="图 24" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727787973805.png" />  

总结
<img alt="图 25" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727788397400.png" />  
<img alt="图 26" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727788592943.png" />  



## 自动配置完整流程
```markdown
1. 导入 starter, 就会导入 autoconfigure 包。
2. autoconfigure 包里面有一个文件 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports, 里面指定的所有启动要加载的自动配置类。
3. @EnableAutoConfiguration 会自动的把上面文件里面写的所有自动配置类都导入进来。xxxAutoConfiguration 是有条件注解进行按需加载。
4. xxxAutoConfiguration 给容器中导入一堆组件, 组件都是从 xxxProperties 中提取属性值。
5. xxxProperties 又是和配置文件进行了绑定。
效果: 导入 starter、修改配置文件, 就能修改底层行为。
```
# 自动配置的初步理解
SpringBoot默认约定：用户配了的用用户的，没配的用默认的
文档：https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties.templating
## 自动配置
导入场景，容器中就会自动配置好这个场景的核心组件
如导入spring-boot-starter-web，容器中就会自动配置好Tomcat、SpringMvC、DataSource等
不喜欢的组件可以自行配置进行替换：
默认用的数据源：HikariDataSource
换成Druid数据源：
```markdown
1. 在 application.yml 中添加 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
2. 在config包下新建一个配置类，使用@Bean注解将Druid数据源注入到容器中
@Configuration
public class DataSourceConfig {
    @Value("${spring.datasource.username}")
    private String username;
    @Value("${spring.datasource.password}")
    private String password;
    @Value("${spring.datasource.url}")
    private String url;
    @Value("${spring.datasource.driverClassName}")
    private String driverClassName;

    @Bean
    DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setUrl(url);
        dataSource.setDriverClassName(driverClassName);
        // ... 配置其他 dataSource 属性
        return dataSource;
    }
}
```
## 默认的包扫描规则
SpringBoot只会扫描主程序所在的包及其下面的子包






