# 自定义starter
在robot-spring-boot-starter中演示
1. 不需要配置文件，因为是别人引自己，引完自己别人当自己的用，别人会自己配
2. 依赖还是要配
3. 要弄个自动配置类将组件注入到容器中，然后在主项目的启动类中import自动配置类。在robot-spring-boot-starter\src\main\java\com\atguigu\robot\starter\RobotAutoConfiguration.java中演示
4. 或者主项目导入自定义注解，自定义注解中import自动配置类(只有3个元注解和@Import)。
5. 或者主项目不用导入东西了，直接自定义starter中的resource/META-INF.spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件，里边写自动配置类的全类名。在robot-spring-boot-starter\src\main\resources\META-INF\spring\org.springframework.boot.autoconfigure.AutoConfiguration.imports中演示
```markdown
1. 所有starter都需要依赖这个基础starter: spring-boot-starter
2. 把所有要抽取的业务组件都放到这个starter中
```

# springboot原理总结
<img alt="图 32" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-03-1727928131308.png" />  

```markdown
# Enablexxx注解，里边有@Import导入注解类，然后让自动配置类基于条件注解进行加载对应组件
# EnableAutoConfiguration注解，里边有@Import导入自动配置类，然后自动配置类会基于条件注解进行加载对应的152个组件
```
完整项目启动流程：
<img alt="图 33" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-03-1727928485072.png" />  


# 生命周期事件（了解）
<img alt="图 29" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-03-1727927065686.png" />  
探针：SpringBoot应用的启动过程可以被看作是一个事件驱动的流程，每个关键阶段都会触发一个事件。这些事件可以被监听器或其他组件感知和处理。（给外界用的）（nginx可以通过就绪探针知道这个服务器是否炸了）
<img alt="图 30" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-03-1727927213361.png" />  

```markdown
# Spring Boot 事件机制
## 事件类型
1. 应用启动过程生命周期事件感知（9大事件）
2. 应用运行中事件感知（无数种）
## 事件驱动开发
### 定义事件
- 任意事件：任意类可以作为事件类，建议命名为 xxxEvent
- 系统事件：继承 ApplicationEvent
### 事件发布
- 组件实现 ApplicationEventPublisherAware
- 自动注入 ApplicationEventPublisher
### 事件监听
- 组件 + 方法标注 @EventListener
```
## 事件驱动（本地消息(事件)模式）（在分布式下用不了） 和 同步阻塞
一个controller调用很多个service就会阻塞
事件驱动：
<img alt="图 31" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-03-1727927564626.png" />  
用这种方式只能在同一个服务器下的springboot项目中使用

```markdown
1. 在启动类的同级目录下新建一个event包，在里边新建一个事件类：
public class UserLoginSucessEvent{}
2. 在controller中
@Autowired
ApplicationEventPublisherpublisher;
UserLoginSuccessEvent event = new UserLoginSuccessEvent(username);
// 发送事件
publisher.publishEvent(event);
3. 在要使用的service中监听这个事件：
@Async // 异步执行 不是同一个线程，多线程，不会同步阻塞 要在启动类加上@EnableAsync//开启
@EventListener(UserLoginSuccessEvent.class)
public void listen(UserLoginSuccessEvent event) {
    log.info("监听到 UserLoginSuccessEvent 事件");
    // 调用业务
}
```


# 生命周期监听（了解）
在springboot-01-demo\src\main\java\com\atguigu\boot\listener中演示
在springboot-01-demo\src\main\resources\META-INF中演示
生命周期流程：
<img alt="图 27" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-03-1727926374788.png" />  

生命周期监听器：可以监听SpringBoot的生命周期，在生命周期的不同阶段执行一些操作
<img alt="图 28" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-03-1727926441085.png" />  

```markdown
# 自定义监听器
1. 创建一个类，放在主程序的同级目录的listener包下，@slf4j public class MySpringApplicationRunListener implements SpringApplicationRunListener
重写方法：
- starting()：在 SpringApplication 启动之前执行 （日志打印不了，因为还没来得及加载，可以用system.out.print）
- environmentPrepared()：在 Environment 准备好之后执行
- contextPrepared()：在 ApplicationContext 准备好之后执行
- contextLoaded()：在 ApplicationContext 加载完成之后执行
- started()：在 SpringApplication 启动之后执行
- running()：在 SpringApplication 运行之后执行
- failed()：在 SpringApplication 启动失败之后执行
2. 在resources下新建META-INF/spring.factories文件，内容如下：
org.springframework.boot.SpringApplicationRunListener=\
com.atguigu.listener.MySpringApplicationRunListener
```

## 监听器和运行器

| 监听器 | 感知阶段 | 配置方式 |
|--------|----------|----------|
| BootstrapRegistryInitializer | 特定阶段：引导初始化 | 1. META-INF/spring.factories<br>2. application.addBootstrapRegistryInitializer() |
| ApplicationContextInitializer | 特定阶段：ioc容器初始化 | 1. META-INF/spring.factories<br>2. application.addInitializers() |
| ApplicationListener | 全阶段 | 1. META-INF/spring.factories<br>2. SpringApplication.addListeners(...)<br>3. @Bean 或 @EventListener |
| SpringApplicationRunListener | 全阶段 | META-INF/spring.factories |
| ApplicationRunner | 特定阶段：感知应用就绪 | @Bean |
| CommandLineRunner | 特定阶段：感知应用就绪 | @Bean |

最佳实践：
1. 应用启动后做事：ApplicationRunner、CommandLineRunner
2. 事件驱动开发：ApplicationListener



# springboot基础功能
## SpringApplication
```markdown
### 自定义 banner
在springboot-01-demo\src\main\resources\application.properties和springboot-01-demo\src\main\resources\banner.txt中演示
启动项目出现的一大坨字符
- 配置文件中设置：spring.banner.location=classpath:banner.txt
- 类路径添加 banner.txt 在里边整上想弄的
- 可以使用在线 ASCII 艺术生成器：https://www.bootschool.net/ascii
### 自定义 SpringApplication
在springboot-01-demo\src\main\java\com\atguigu\boot\Springboot01DemoApplication.java中演示
有两种方式可以自定义 SpringApplication：
1. 使用 new SpringApplication()
   - 直接创建 SpringApplication 实例，然后自定义其属性
2. 使用 new SpringApplicationBuilder()
   - 使用 Builder 模式来创建和配置 SpringApplication
这两种方法都允许你自定义 SpringApplication 的各种属性和行为，例如：
- 禁用特定的自动配置类
- 设置应用程序类型
- 自定义 banner 模式
- 添加自定义的监听器
- 等等
示例代码：

```java
// 方法 1: 使用 new SpringApplication()
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MyApp.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}
// 方法 2: 使用 new SpringApplicationBuilder()
public static void main(String[] args) {
    new SpringApplicationBuilder()
        .sources(MyApp.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);
}
```
通过这些方法，你可以更精细地控制 Spring Boot 应用程序的启动过程和行为。
```

## yaml配置文件
如果yaml和properties同时出现相同配置，则properties的优先级更高

在springboot-01-demo\src\main\resources\application.yaml中演示属性(list，map，对象)的具体赋值语法等
```markdown
# SpringBoot 配置管理
## 痛点
SpringBoot 集中化管理配置，通常使用 application.properties
## 问题
- 配置多以后难以阅读和修改
- 层级结构辨识度不高
## YAML 配置文件
为解决上述问题，可以使用 YAML 格式的配置文件。
### YAML 语法规则
1. 大小写敏感
2. 键值对写法
   - 使用格式：`key: value`
   - 注意：冒号后面要有一个空格
3. 使用缩进表示层级关系
   - 缩进时不允许使用 Tab 键，只能使用空格
   - 缩进的空格数目不重要，只要相同层级的元素左对齐即可
4. 注释
   - 以 `#` 开头的行为注释，从这个字符一直到行尾，都会被解析器忽略
5. Value 支持的数据类型
   - 对象：键值对的集合
     例如：映射（map）/ 哈希（hash）/ 字典（dictionary）
   - 数组：一组按次序排列的值
     例如：序列（sequence）/ 列表（list）
   - 纯量：单个的、不可再分的值
     例如：字符串、数字、布尔值、日期
使用 YAML 格式可以提高配置文件的可读性和结构化程度，特别是在处理复杂配置时更有优势。
```

## 属性绑定
@ConfigurationProperties


# @SpringBootApplication注解
```markdown
3个子注解：
@SpringBootConfiguration：容器中的普通组件
    @Configuration：指定这是一个配置类
@EnableAutoConfiguration：开启自动配置
    @AutoConfigurationPackage：指定包扫描规则，扫描主程序所在包及其子包 （哪些要） （批量导入组件）
    @Import(AutoConfigurationImportSelector.class)：在类路径下找到文件：
META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports（在spring-boot-autoconfigure包下），导入152个自动配置类。 org.springframework.boot.autoconfigure.AutoConfiguration是@AutoConfigurationPackage的子类全类名
@ComponentScan：包扫描，扫描主程序所在包及其子包，排除哪些不要 （哪些不要）
```
解释为什么配了数据源后，springboot会自动配置好数据源：
配了数据源后，根据条件注解就不会再配了
<img alt="图 21" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727787057423.png" />  

解释为什么自动导入了HikariDataSource：
因为springboot默认加载了HikariDataSource依赖，所以这里会检测到，然后导入hikariDataSource，用户已经配置了就不放，用户没配置就默认
<img alt="图 23" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727787275329.png" />  

解释属性自动配置（开启属性与配置文件的自动绑定功能）
<img alt="图 24" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727787973805.png" />  

总结
<img alt="图 25" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727788397400.png" />  
<img alt="图 26" src="%E9%A2%9D%E5%A4%96%E7%9F%A5%E8%AF%86.assets/2024-10-01-1727788592943.png" />  



## 自动配置完整流程
```markdown
1. 导入 starter, 就会导入 autoconfigure 包。
2. autoconfigure 包里面有一个文件 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports, 里面指定的所有启动要加载的自动配置类。
3. @EnableAutoConfiguration 会自动的把上面文件里面写的所有自动配置类都导入进来。xxxAutoConfiguration 是有条件注解进行按需加载。
4. xxxAutoConfiguration 给容器中导入一堆组件, 组件都是从 xxxProperties 中提取属性值。
5. xxxProperties 又是和配置文件进行了绑定。
效果: 导入 starter、修改配置文件, 就能修改底层行为。
```

# 自动配置的初步理解
SpringBoot默认约定：用户配了的用用户的，没配的用默认的
文档：https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties.templating
## 自动配置
导入场景，容器中就会自动配置好这个场景的核心组件
如导入spring-boot-starter-web，容器中就会自动配置好Tomcat、SpringMvC、DataSource等
不喜欢的组件可以自行配置进行替换：
默认用的数据源：HikariDataSource
换成Druid数据源：
```markdown
1. 在 application.yml 中添加 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
2. 在config包下新建一个配置类，使用@Bean注解将Druid数据源注入到容器中
@Configuration
public class DataSourceConfig {
    @Value("${spring.datasource.username}")
    private String username;
    @Value("${spring.datasource.password}")
    private String password;
    @Value("${spring.datasource.url}")
    private String url;
    @Value("${spring.datasource.driverClassName}")
    private String driverClassName;

    @Bean
    DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setUrl(url);
        dataSource.setDriverClassName(driverClassName);
        // ... 配置其他 dataSource 属性
        return dataSource;
    }
}
```

## 默认的包扫描规则
SpringBoot只会扫描主程序所在的包及其下面的子包





